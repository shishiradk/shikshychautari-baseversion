from fastapi import FastAPI, File, UploadFile, Form, HTTPException
from fastapi.responses import Response, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import os
import uuid
import tempfile
import boto3
from utils import (
    extract_text_from_pdfs, 
    chunk_text, 
    create_vector_store, 
    load_vector_store, 
    generate_predicted_paper, 
    paper_to_pdf_bytes, 
    REPORTLAB_OK
)

# Pydantic Models
class GeneratePaperRequest(BaseModel):
    bucket_name: str
    old_question_prefix: str
    syllabus_prefix: str
    predicted_question_prefix: str
    additional_instructions: Optional[str] = None

# FastAPI app initialization
app = FastAPI(
    title="üéì Question Paper Generator API",
    description="""
    ## üìö AI-Powered Question Paper Prediction
    
    Upload your **syllabus PDFs** and **old question papers**, and get a **predicted question paper** generated by AI.
    
    ### ‚ú® Features:
    - ü§ñ **AI-Powered**: Uses OpenAI GPT-4 for intelligent question generation
    - üìÑ **Multi-PDF Support**: Upload multiple syllabus and question paper files
    - üéØ **Smart Analysis**: Analyzes patterns from past papers and syllabus content
    - üì• **Direct PDF Output**: Get your predicted paper as a downloadable PDF
    - ‚ö° **One-Click Generation**: Single endpoint for complete workflow
    
    ### üöÄ How to Use:
    1. Click on the **POST /generate-paper** endpoint below
    2. Upload your PDF files (syllabus + old questions)
    3. Add optional instructions if needed
    4. Click **Execute** and download your predicted paper!
    
    ---
    """,
    version="2.0.0",
    docs_url="/swagger",
    redoc_url="/redoc",
    contact={
        "name": "Question Paper Generator",
        "url": "https://github.com/your-repo",
    },
    license_info={
        "name": "MIT License",
        "url": "https://opensource.org/licenses/MIT",
    },
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",
        "http://localhost:3001", 
        "http://localhost:3002",
        "http://localhost:3003",
        "http://127.0.0.1:3000",
        "http://127.0.0.1:3001",
        "http://127.0.0.1:3002", 
        "http://127.0.0.1:3003"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# S3 Utility functions
def get_s3_client():
    """Get S3 client with credentials"""
    return boto3.client(
        's3',
        aws_access_key_id=os.getenv("AWS_ACCESS_KEY_ID"),
        aws_secret_access_key=os.getenv("AWS_SECRET_ACCESS_KEY"),
        region_name=os.getenv("AWS_REGION", "eu-north-1")
    )

def download_pdfs_from_s3(bucket_name: str, prefix: str) -> List[bytes]:
    """Download all PDF files from S3 bucket with given prefix"""
    s3_client = get_s3_client()
    pdf_contents = []
    temp_files = []  # Keep track of temp files for cleanup
    
    try:
        # List objects with the prefix
        response = s3_client.list_objects_v2(Bucket=bucket_name, Prefix=prefix)
        
        if 'Contents' not in response:
            raise HTTPException(status_code=404, detail=f"No files found in bucket {bucket_name} with prefix {prefix}")
        
        # Download each PDF file
        for obj in response['Contents']:
            key = obj['Key']
            if key.lower().endswith('.pdf'):
                print(f"üì• Downloading: {key}")
                
                # Create temporary file
                tmp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.pdf')
                temp_files.append(tmp_file.name)
                tmp_file.close()
                
                try:
                    # Download file to temporary location
                    s3_client.download_file(bucket_name, key, tmp_file.name)
                    
                    # Read the file content
                    with open(tmp_file.name, 'rb') as f:
                        pdf_content = f.read()
                        pdf_contents.append(pdf_content)
                        
                except Exception as e:
                    print(f"‚ö†Ô∏è Error processing {key}: {str(e)}")
                    continue
        
        if not pdf_contents:
            raise HTTPException(status_code=404, detail=f"No PDF files found in bucket {bucket_name} with prefix {prefix}")
        
        print(f"‚úÖ Downloaded {len(pdf_contents)} PDF files from S3")
        return pdf_contents
        
    except Exception as e:
        if "NoSuchBucket" in str(e):
            raise HTTPException(status_code=404, detail=f"Bucket {bucket_name} not found")
        elif "AccessDenied" in str(e):
            raise HTTPException(status_code=403, detail=f"Access denied to bucket {bucket_name}")
        else:
            raise HTTPException(status_code=500, detail=f"Error downloading from S3: {str(e)}")
    
    finally:
        # Clean up all temporary files
        for temp_file in temp_files:
            try:
                if os.path.exists(temp_file):
                    os.unlink(temp_file)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not delete temp file {temp_file}: {str(e)}")
                # Continue with cleanup even if one file fails

def upload_pdf_to_s3(pdf_bytes: bytes, bucket_name: str, output_prefix: str, filename: str) -> str:
    """Upload PDF to S3 and return the full S3 key"""
    s3_client = get_s3_client()
    
    # Create the full S3 key
    s3_key = f"{output_prefix.rstrip('/')}/{filename}"
    
    try:
        s3_client.put_object(
            Bucket=bucket_name,
            Key=s3_key,
            Body=pdf_bytes,
            ContentType='application/pdf'
        )
        
        print(f"‚úÖ Uploaded PDF to S3: {s3_key}")
        return s3_key
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error uploading to S3: {str(e)}")

# API Endpoints
@app.get("/", tags=["Info"])
async def root():
    """
    ## üè† API Information
    
    Welcome to the Question Paper Generator API! This API uses AI to predict future exam questions.
    """
    return {
        "üéì": "Question Paper Generator API",
        "version": "2.0.0",
        "üìñ": "Interactive docs at /swagger",
        "üöÄ": "Main endpoint: POST /generate-paper",
        "üí°": "Upload syllabus + old questions ‚Üí Get predicted paper PDF",
        "ü§ñ": "Powered by OpenAI GPT-4 + LangChain"
    }

@app.post("/generate-paper", 
          tags=["üéØ Question Paper Generation"],
          summary="üöÄ Generate Predicted Question Paper (File Upload)",
          description="Upload syllabus and old question PDFs to generate a predicted exam paper",
          response_description="PDF file containing the predicted question paper")
async def generate_paper_from_files(
    syllabus_files: List[UploadFile] = File(
        ..., 
        description="üìö **Syllabus PDF Files** - Upload one or more PDF files containing syllabus/course content"
    ),
    old_question_files: List[UploadFile] = File(
        ..., 
        description="üìÑ **Old Question Papers** - Upload one or more PDF files with past exam questions"
    ),
    additional_instructions: Optional[str] = Form(
        None,
        description="üí¨ **Additional Instructions** (Optional) - Specific requirements like 'Focus on practical questions' or 'Include numerical problems'"
    )
):
    """
    ## üéì Generate AI-Predicted Question Paper
    
    This endpoint analyzes your syllabus and past question papers to generate a predicted future exam paper.
    
    ### üìã What you need:
    - **Syllabus PDFs**: Course syllabus, curriculum, or study materials
    - **Old Question Papers**: Previous years' exam papers or practice questions
    
    ### ü§ñ What it does:
    1. **Extracts text** from all uploaded PDFs
    2. **Analyzes patterns** in past questions using AI
    3. **Cross-references** with syllabus content
    4. **Generates** a predicted question paper
    5. **Returns** a formatted PDF ready for download
    
    ### ‚ö° Features:
    - Supports multiple PDF files for both syllabus and questions
    - AI-powered pattern recognition and question generation
    - Maintains academic formatting and structure
    - Optional custom instructions for specific requirements
    
    ### üí° Tips:
    - Upload multiple years of question papers for better predictions
    - Include detailed syllabus for comprehensive coverage
    - Use additional instructions for specific focus areas
    
    ---
    **Returns:** PDF file containing your predicted question paper
    """
    try:
        # Generate unique session ID for this request
        session_id = str(uuid.uuid4())
        
        # Validate and process syllabus files
        syllabus_pdf_data = []
        for file in syllabus_files:
            if not file.filename.lower().endswith('.pdf'):
                raise HTTPException(status_code=400, detail=f"Syllabus file {file.filename} is not a PDF")
            content = await file.read()
            syllabus_pdf_data.append(content)
        
        # Validate and process old question files
        old_question_pdf_data = []
        for file in old_question_files:
            if not file.filename.lower().endswith('.pdf'):
                raise HTTPException(status_code=400, detail=f"Old question file {file.filename} is not a PDF")
            content = await file.read()
            old_question_pdf_data.append(content)
        
        # Extract text from syllabus PDFs
        syllabus_text = extract_text_from_pdfs(syllabus_pdf_data)
        if not syllabus_text.strip():
            raise HTTPException(status_code=400, detail="No text could be extracted from syllabus PDF files")
        
        # Extract text from old question PDFs
        old_questions_text = extract_text_from_pdfs(old_question_pdf_data)
        if not old_questions_text.strip():
            raise HTTPException(status_code=400, detail="No text could be extracted from old question PDF files")
        
        # Create chunks and vector store
        chunks = chunk_text(old_questions_text)
        vector_store_path = create_vector_store(chunks, session_id)
        
        # Load vector store and generate paper
        past_db = load_vector_store(session_id)
        predicted_paper, past_context, subject_name = generate_predicted_paper(
            past_db, 
            syllabus_text, 
            additional_instructions or ""
        )
        
        # Generate PDF
        if not REPORTLAB_OK:
            raise HTTPException(
                status_code=501, 
                detail="PDF generation not available. Install reportlab: pip install reportlab"
            )
        
        pdf_bytes = paper_to_pdf_bytes("Predicted Question Paper", predicted_paper, past_context, subject_name)
        
        # Clean up vector store files
        try:
            import shutil
            if os.path.exists(vector_store_path):
                shutil.rmtree(vector_store_path)
        except Exception:
            pass  # Ignore cleanup errors
        
        # Return PDF as response
        return Response(
            content=pdf_bytes,
            media_type="application/pdf",
            headers={
                "Content-Disposition": f"attachment; filename=predicted_paper_{session_id[:8]}.pdf",
                "Content-Length": str(len(pdf_bytes))
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        # Clean up on error
        try:
            import shutil
            vector_store_path = f"faiss_index_{session_id}"
            if os.path.exists(vector_store_path):
                shutil.rmtree(vector_store_path)
        except Exception:
            pass
        
        raise HTTPException(status_code=500, detail=f"Error generating question paper: {str(e)}")

@app.post("/generate-paper-s3", 
           tags=["‚òÅÔ∏è S3 Question Paper Generation"],
           summary="‚òÅÔ∏è Generate from S3 and Upload to S3",
           description="Download PDFs from S3 (old questions + syllabus), generate question paper, and upload result back to S3",
           response_description="Success message with S3 location of generated PDF")
async def generate_paper_from_s3(
    data: GeneratePaperRequest
):
    """
    ## ‚òÅÔ∏è Generate Question Paper from S3 and Upload Back
    
    This endpoint downloads old question PDFs AND syllabus PDFs from S3, generates a predicted question paper, 
    and uploads the result back to S3 using the provided predicted question prefix.
    
    ### üìã What you need:
    - **S3 Bucket**: Contains old question PDFs and syllabus PDFs
    - **Old Question Prefix**: Where old questions are stored in S3 (e.g., 'course-xxx/semester-xxx/subject-xxx/questionpaper/')
    - **Syllabus Prefix**: Where syllabus PDFs are stored in S3 (e.g., 'course-xxx/semester-xxx/subject-xxx/syllabus/')
    - **Predicted Question Prefix**: Where generated PDF will be uploaded (e.g., 'course-xxx/semester-xxx/subject-xxx/predictedpaper/')
    
    ### ü§ñ What it does:
    1. **Downloads** all PDFs from S3 bucket with old question prefix
    2. **Downloads** all PDFs from S3 bucket with syllabus prefix
    3. **Combines** both sets of PDFs for analysis
    4. **Generates** predicted question paper using AI
    5. **Uploads** result to S3 with the provided predicted question prefix
    6. **Returns** success message with S3 location
    
    ### ‚ö° Features:
    - Automatic S3 download of old question papers AND syllabus PDFs
    - AI-powered question generation
    - **Direct prefix control** - you specify exactly where to upload
    - Automatic upload to specified S3 location
    - Returns S3 key for easy access
    
    ### üìÅ Prefix Example:
    - **Old Questions**: `course-077af986-1e0d-452f-835a-38d21f5d3099/semester-eace96be-c43b-42d8-a3fa-b11f65bd4ca5/subject-82d1725d-16ad-4164-90ab-12d323264042/questionpaper/`
    - **Syllabus**: `course-077af986-1e0d-452f-835a-38d21f5d3099/semester-eace96be-c43b-42d8-a3fa-b11f65bd4ca5/subject-82d1725d-16ad-4164-90ab-12d323264042/syllabus/`
    - **Predicted Paper**: `course-077af986-1e0d-452f-835a-38d21f5d3099/semester-eace96be-c43b-42d8-a3fa-b11f65bd4ca5/subject-82d1725d-16ad-4164-90ab-12d323264042/predictedpaper/`
    
    ---
    **Returns:** Success message with S3 location of generated PDF
    """
    try:
        # Generate unique session ID for this request
        session_id = str(uuid.uuid4())
        
        print(f"üöÄ Starting S3-based question paper generation...")
        print(f"üì¶ Bucket: {data.bucket_name}")
        print(f"üì• Old Question prefix: {data.old_question_prefix}")
        print(f"üìö Syllabus prefix: {data.syllabus_prefix}")
        print(f"üì§ Predicted Question prefix: {data.predicted_question_prefix}")
        
        # Step 1: Download old question PDFs from S3
        print("üì• Downloading old question PDFs from S3...")
        old_question_pdfs = download_pdfs_from_s3(data.bucket_name, data.old_question_prefix)
        
        # Step 2: Download syllabus PDFs from S3
        print("üìö Downloading syllabus PDFs from S3...")
        syllabus_pdfs = download_pdfs_from_s3(data.bucket_name, data.syllabus_prefix)
        
       
        
        # Step 3: Extract text from syllabus PDFs
        print("üîç Extracting text from syllabus PDFs...")
        syllabus_text = extract_text_from_pdfs(syllabus_pdfs)
        if not syllabus_text.strip():
            raise HTTPException(status_code=400, detail="No text could be extracted from syllabus PDF files")

        # Step 4: Extract text from old question PDFs
        print("üîç Extracting text from old question PDFs...")
        old_questions_text = extract_text_from_pdfs(old_question_pdfs)
        if not old_questions_text.strip():
            raise HTTPException(status_code=400, detail="No text could be extracted from old question PDF files")
        
        # Step 5: Generate question paper
        print("ü§ñ Generating predicted question paper...")
        chunks = chunk_text(old_questions_text)
        vector_store_path = create_vector_store(chunks, session_id)
        
        past_db = load_vector_store(session_id)
        predicted_paper, past_context, subject_name = generate_predicted_paper(
            past_db, 
            syllabus_text, 
            data.additional_instructions or ""
        )
        
        # Step 5: Generate PDF
        if not REPORTLAB_OK:
            raise HTTPException(
                status_code=501, 
                detail="PDF generation not available. Install reportlab: pip install reportlab"
            )
        
        pdf_bytes = paper_to_pdf_bytes("Predicted Question Paper", predicted_paper, past_context, subject_name)
        
        # Step 6: Upload to S3 using the provided predicted question prefix
        print("üì§ Uploading generated PDF to S3...")
        timestamp = session_id[:8]
        filename = f"predicted_paper_{timestamp}.pdf"
        s3_key = upload_pdf_to_s3(pdf_bytes, data.bucket_name, data.predicted_question_prefix, filename)
        
        # Step 7: Clean up
        try:
            import shutil
            if os.path.exists(vector_store_path):
                shutil.rmtree(vector_store_path)
        except Exception:
            pass
        
        # Step 8: Return success response
        return JSONResponse(
            content={
                "success": True,
                "message": "Question paper generated and uploaded successfully!",
                "s3_bucket": data.bucket_name,
                "s3_key": s3_key,
                "s3_url": f"https://{data.bucket_name}.s3.amazonaws.com/{s3_key}",
                "file_size": len(pdf_bytes),
                "session_id": session_id,
                "predicted_question_prefix": data.predicted_question_prefix
            },
            status_code=200
        )
        
    except HTTPException:
        raise
    except Exception as e:
        # Clean up on error
        try:
            import shutil
            vector_store_path = f"faiss_index_{session_id}"
            if os.path.exists(vector_store_path):
                shutil.rmtree(vector_store_path)
        except Exception:
            pass
        
        raise HTTPException(status_code=500, detail=f"Error in S3-based generation: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    
    # Check if required environment variables are set
    missing_vars = []
    
    if not os.getenv("OPENAI_API_KEY"):
        missing_vars.append("OPENAI_API_KEY")
    
    if not os.getenv("AWS_ACCESS_KEY_ID"):
        missing_vars.append("AWS_ACCESS_KEY_ID")
    
    if not os.getenv("AWS_SECRET_ACCESS_KEY"):
        missing_vars.append("AWS_SECRET_ACCESS_KEY")
    
    if missing_vars:
        print("‚ö†Ô∏è  Warning: Missing required environment variables:")
        for var in missing_vars:
            print(f"   - {var}")
        print("\n   Please set these in a .env file or environment variables")
        print("   Example .env file:")
        print("   OPENAI_API_KEY=your_openai_key")
        print("   AWS_ACCESS_KEY_ID=your_aws_key")
        print("   AWS_SECRET_ACCESS_KEY=your_aws_secret")
        print("   AWS_REGION=eu-north-1")
        exit(1)
    
    print("üöÄ Starting Question Paper Generator API...")
    print("üìö Swagger UI: http://localhost:8000/swagger")
    print("üîó API Root: http://localhost:8000/")
    print("=" * 50)
    
    uvicorn.run(app, host="0.0.0.0", port=8000)
 